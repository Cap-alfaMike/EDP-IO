package com.edpio.api.service;

import com.edpio.api.model.Alert;
import com.edpio.api.provider.DatabricksProvider;
import com.edpio.api.provider.LLMProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import java.util.*;

/**
 * Service for observability, alerts, and LLM-powered analysis.
 * Analyzes logs, detects schema drift, and provides incident intelligence.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ObservabilityService {
    
    private final DatabricksProvider databricksProvider;
    private final LLMProvider llmProvider;
    
    /**
     * Get active alerts from pipeline monitoring.
     */
    public List<Alert> getAlerts() {
        List<Alert> alerts = new ArrayList<>();
        
        // In production: Query monitoring tables for recent failures/anomalies
        // SELECT * FROM observability.alerts WHERE is_active = true
        
        alerts.add(Alert.builder()
                .severity("WARNING")
                .title("Schema Drift Detected")
                .description("New column 'loyalty_points' in Oracle CRM customers table")
                .timestamp("2 hours ago")
                .recommendedAction("Update data contract")
                .build());
        
        alerts.add(Alert.builder()
                .severity("INFO")
                .title("Slow Pipeline")
                .description("SQL Server Orders ingestion took 45 min (SLA: 30 min)")
                .timestamp("1.5 hours ago")
                .recommendedAction("Review query performance")
                .build());
        
        return alerts;
    }
    
    /**
     * Detect schema changes in source systems.
     * Uses LLM to assess business impact.
     */
    public Map<String, Object> detectSchemaDrift(String tableName) {
        try {
            // In production: Compare current vs previous schema
            String currentSchema = getTableSchema(tableName);
            String previousSchema = getPreviousTableSchema(tableName);
            
            // Detect changes
            List<String> changes = identifySchemaChanges(currentSchema, previousSchema);
            
            if (changes.isEmpty()) {
                return Map.of("status", "OK", "changes_detected", false);
            }
            
            // Use LLM to assess impact
            String impact = assessImpactWithLLM(tableName, changes);
            
            return Map.of(
                "table", tableName,
                "status", "DRIFT_DETECTED",
                "changes", changes,
                "llm_assessment", impact
            );
        } catch (Exception e) {
            log.error("Schema drift detection failed for {}", tableName, e);
            return Map.of("error", e.getMessage());
        }
    }
    
    /**
     * Get data lineage for a table.
     */
    public Map<String, Object> getLineage(String tableName) {
        Map<String, Object> lineage = new HashMap<>();
        
        // In production: Query dbt manifest or lineage service
        lineage.put("table", tableName);
        lineage.put("upstream", List.of(
            "oracle.customers",
            "sql_server.orders"
        ));
        lineage.put("downstream", List.of(
            "gold.dim_customer",
            "power_bi.customer_dashboard"
        ));
        
        return lineage;
    }
    
    private String getTableSchema(String tableName) {
        // In production: Query INFORMATION_SCHEMA
        return String.format("{\"table\": \"%s\", \"columns\": [\"id\", \"name\", \"email\"]}", tableName);
    }
    
    private String getPreviousTableSchema(String tableName) {
        // In production: Query schema history table
        return String.format("{\"table\": \"%s\", \"columns\": [\"id\", \"name\"]}", tableName);
    }
    
    private List<String> identifySchemaChanges(String current, String previous) {
        List<String> changes = new ArrayList<>();
        
        // Simplified comparison
        if (!current.equals(previous)) {
            changes.add("Column 'email' added");
        }
        
        return changes;
    }
    
    private String assessImpactWithLLM(String table, List<String> changes) {
        String prompt = String.format(
            "Assess the impact of these schema changes to %s: %s. " +
            "What tables are affected and what actions should be taken?",
            table, changes
        );
        
        // Would call LLM for impact assessment
        return "Impact assessment would be generated by LLM";
    }
}
